// This file is generated by tools, DO NOT EDIT.
package runner

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/cloudcarver/anchor/pkg/apigen"
	"github.com/cloudcarver/anchor/pkg/task"
	"github.com/cloudcarver/anchor/pkg/task/worker"
	"github.com/cloudcarver/anchor/pkg/utils"
	"github.com/pkg/errors"
)

func init() {
	utils.Noop()
}

const ( 
	AutoBackup = "AutoBackup" 

	AutoDiagnostic = "AutoDiagnostic" 

	DeleteClusterDiagnostic = "DeleteClusterDiagnostic" 

	DeleteSnapshot = "DeleteSnapshot" 

	DeleteOpaqueKey = "DeleteOpaqueKey" 
)

type TaskRunner interface { 
    // Auto backup
	RunAutoBackup(ctx context.Context, params *AutoBackupParameters, overrides ...task.TaskOverride) (int32, error)

    // Auto diagnostic
	RunAutoDiagnostic(ctx context.Context, params *AutoDiagnosticParameters, overrides ...task.TaskOverride) (int32, error)

    // Delete cluster diagnostic
	RunDeleteClusterDiagnostic(ctx context.Context, params *DeleteClusterDiagnosticParameters, overrides ...task.TaskOverride) (int32, error)

    // Delete snapshot
	RunDeleteSnapshot(ctx context.Context, params *DeleteSnapshotParameters, overrides ...task.TaskOverride) (int32, error)

    // Delete opaque key
	RunDeleteOpaqueKey(ctx context.Context, params *DeleteOpaqueKeyParameters, overrides ...task.TaskOverride) (int32, error)
}

type Client struct {
	taskStore task.TaskStoreInterface
	now       func() time.Time
}

func NewTaskRunner(taskStore task.TaskStoreInterface) TaskRunner {
	return &Client{
		taskStore: taskStore,
		now:       time.Now,
	}
}


func (c *Client) RunAutoBackup(ctx context.Context, params *AutoBackupParameters, overrides ...task.TaskOverride) (int32, error) {
	payload, err := params.Marshal()
	if err != nil {
		return 0, err
	}

	spec := apigen.TaskSpec{
		Type:    AutoBackup,
		Payload: payload,
	}
	attributes := apigen.TaskAttributes{}
	attributes.Timeout = utils.Ptr("30m")
	
	attributes.Cronjob = &apigen.TaskCronjob{
		CronExpression: "0 */6 * * *",
	}
	task := &apigen.Task{
		Attributes: attributes,
		Spec:       spec,
		Status:     apigen.Pending,
	}
	
	for _, override := range overrides {
		if err := override(task); err != nil {
			return 0, errors.Wrap(err, "failed to apply task override")
		}
	}
	taskID, err := c.taskStore.PushTask(ctx, task)
	if err != nil {
		return 0, err
	}
	return taskID, nil
}
func (c *Client) RunAutoDiagnostic(ctx context.Context, params *AutoDiagnosticParameters, overrides ...task.TaskOverride) (int32, error) {
	payload, err := params.Marshal()
	if err != nil {
		return 0, err
	}

	spec := apigen.TaskSpec{
		Type:    AutoDiagnostic,
		Payload: payload,
	}
	attributes := apigen.TaskAttributes{}
	attributes.Timeout = utils.Ptr("30m")
	
	attributes.Cronjob = &apigen.TaskCronjob{
		CronExpression: "0 */6 * * *",
	}
	task := &apigen.Task{
		Attributes: attributes,
		Spec:       spec,
		Status:     apigen.Pending,
	}
	
	for _, override := range overrides {
		if err := override(task); err != nil {
			return 0, errors.Wrap(err, "failed to apply task override")
		}
	}
	taskID, err := c.taskStore.PushTask(ctx, task)
	if err != nil {
		return 0, err
	}
	return taskID, nil
}
func (c *Client) RunDeleteClusterDiagnostic(ctx context.Context, params *DeleteClusterDiagnosticParameters, overrides ...task.TaskOverride) (int32, error) {
	payload, err := params.Marshal()
	if err != nil {
		return 0, err
	}

	spec := apigen.TaskSpec{
		Type:    DeleteClusterDiagnostic,
		Payload: payload,
	}
	attributes := apigen.TaskAttributes{}
	attributes.Timeout = utils.Ptr("30m")
	attributes.RetryPolicy = &apigen.TaskRetryPolicy{
		Interval:             "30m",
		AlwaysRetryOnFailure: true,
	}
	
	task := &apigen.Task{
		Attributes: attributes,
		Spec:       spec,
		Status:     apigen.Pending,
	}
	
	for _, override := range overrides {
		if err := override(task); err != nil {
			return 0, errors.Wrap(err, "failed to apply task override")
		}
	}
	taskID, err := c.taskStore.PushTask(ctx, task)
	if err != nil {
		return 0, err
	}
	return taskID, nil
}
func (c *Client) RunDeleteSnapshot(ctx context.Context, params *DeleteSnapshotParameters, overrides ...task.TaskOverride) (int32, error) {
	payload, err := params.Marshal()
	if err != nil {
		return 0, err
	}

	spec := apigen.TaskSpec{
		Type:    DeleteSnapshot,
		Payload: payload,
	}
	attributes := apigen.TaskAttributes{}
	attributes.Timeout = utils.Ptr("30m")
	attributes.RetryPolicy = &apigen.TaskRetryPolicy{
		Interval:             "30m",
		AlwaysRetryOnFailure: true,
	}
	
	task := &apigen.Task{
		Attributes: attributes,
		Spec:       spec,
		Status:     apigen.Pending,
	}
	
	for _, override := range overrides {
		if err := override(task); err != nil {
			return 0, errors.Wrap(err, "failed to apply task override")
		}
	}
	taskID, err := c.taskStore.PushTask(ctx, task)
	if err != nil {
		return 0, err
	}
	return taskID, nil
}
func (c *Client) RunDeleteOpaqueKey(ctx context.Context, params *DeleteOpaqueKeyParameters, overrides ...task.TaskOverride) (int32, error) {
	payload, err := params.Marshal()
	if err != nil {
		return 0, err
	}

	spec := apigen.TaskSpec{
		Type:    DeleteOpaqueKey,
		Payload: payload,
	}
	attributes := apigen.TaskAttributes{}
	attributes.Timeout = utils.Ptr("30m")
	attributes.RetryPolicy = &apigen.TaskRetryPolicy{
		Interval:             "30m",
		AlwaysRetryOnFailure: true,
	}
	
	task := &apigen.Task{
		Attributes: attributes,
		Spec:       spec,
		Status:     apigen.Pending,
	}
	
	for _, override := range overrides {
		if err := override(task); err != nil {
			return 0, errors.Wrap(err, "failed to apply task override")
		}
	}
	taskID, err := c.taskStore.PushTask(ctx, task)
	if err != nil {
		return 0, err
	}
	return taskID, nil
}


type AutoBackupParameters struct { 
    // 
	ClusterID int32 `json:"clusterID" yaml:"clusterID"`

    // e.g. 1h, 1d, 1w
	RetentionDuration string `json:"retentionDuration" yaml:"retentionDuration"`
}

type AutoDiagnosticParameters struct { 
    // e.g. 1h, 1d, 1w
	RetentionDuration string `json:"retentionDuration" yaml:"retentionDuration"`

    // 
	ClusterID int32 `json:"clusterID" yaml:"clusterID"`
}

type DeleteClusterDiagnosticParameters struct { 
    // 
	ClusterID int32 `json:"clusterID" yaml:"clusterID"`

    // 
	DiagnosticID int32 `json:"diagnosticID" yaml:"diagnosticID"`
}

type DeleteSnapshotParameters struct { 
    // 
	ClusterID int32 `json:"clusterID" yaml:"clusterID"`

    // 
	SnapshotID int64 `json:"snapshotID" yaml:"snapshotID"`
}

type DeleteOpaqueKeyParameters struct { 
    // 
	KeyID int64 `json:"keyID" yaml:"keyID"`
}

func (r *AutoBackupParameters) Parse(spec json.RawMessage) error {
	return json.Unmarshal(spec, r)
}

func (r *AutoBackupParameters) Marshal() (json.RawMessage, error) {
	return json.Marshal(r)
}
func (r *AutoDiagnosticParameters) Parse(spec json.RawMessage) error {
	return json.Unmarshal(spec, r)
}

func (r *AutoDiagnosticParameters) Marshal() (json.RawMessage, error) {
	return json.Marshal(r)
}
func (r *DeleteClusterDiagnosticParameters) Parse(spec json.RawMessage) error {
	return json.Unmarshal(spec, r)
}

func (r *DeleteClusterDiagnosticParameters) Marshal() (json.RawMessage, error) {
	return json.Marshal(r)
}
func (r *DeleteSnapshotParameters) Parse(spec json.RawMessage) error {
	return json.Unmarshal(spec, r)
}

func (r *DeleteSnapshotParameters) Marshal() (json.RawMessage, error) {
	return json.Marshal(r)
}
func (r *DeleteOpaqueKeyParameters) Parse(spec json.RawMessage) error {
	return json.Unmarshal(spec, r)
}

func (r *DeleteOpaqueKeyParameters) Marshal() (json.RawMessage, error) {
	return json.Marshal(r)
}

type ExecutorInterface interface { 
    // Auto backup
	ExecuteAutoBackup(ctx context.Context, params *AutoBackupParameters) error

    // Auto diagnostic
	ExecuteAutoDiagnostic(ctx context.Context, params *AutoDiagnosticParameters) error

    // Delete cluster diagnostic
	ExecuteDeleteClusterDiagnostic(ctx context.Context, params *DeleteClusterDiagnosticParameters) error

    // Delete snapshot
	ExecuteDeleteSnapshot(ctx context.Context, params *DeleteSnapshotParameters) error

    // Delete opaque key
	ExecuteDeleteOpaqueKey(ctx context.Context, params *DeleteOpaqueKeyParameters) error
}

type TaskHandler struct {
	executor ExecutorInterface

	externalTaskHandler []worker.TaskHandler
}

func NewTaskHandler(executor ExecutorInterface) worker.TaskHandler {
	return &TaskHandler{
		executor: executor,
	}
}

func (f *TaskHandler) RegisterTaskHandler(handler worker.TaskHandler) {
	f.externalTaskHandler = append(f.externalTaskHandler, handler)
}

func (f *TaskHandler) HandleTask(ctx context.Context, spec worker.TaskSpec) error {
	for _, handler := range f.externalTaskHandler {
		if err := handler.HandleTask(ctx, spec); err != nil {
			if errors.Is(err, worker.ErrUnknownTaskType) {
				continue
			}
			return err
		}
		return nil
	}

	switch spec.GetType() { 
	case AutoBackup:
		var params AutoBackupParameters
		if err := params.Parse(spec.GetPayload()); err != nil {
			return fmt.Errorf("failed to parse AutoBackup parameters: %w", err)
		}
		return f.executor.ExecuteAutoBackup(ctx, &params)
		
	case AutoDiagnostic:
		var params AutoDiagnosticParameters
		if err := params.Parse(spec.GetPayload()); err != nil {
			return fmt.Errorf("failed to parse AutoDiagnostic parameters: %w", err)
		}
		return f.executor.ExecuteAutoDiagnostic(ctx, &params)
		
	case DeleteClusterDiagnostic:
		var params DeleteClusterDiagnosticParameters
		if err := params.Parse(spec.GetPayload()); err != nil {
			return fmt.Errorf("failed to parse DeleteClusterDiagnostic parameters: %w", err)
		}
		return f.executor.ExecuteDeleteClusterDiagnostic(ctx, &params)
		
	case DeleteSnapshot:
		var params DeleteSnapshotParameters
		if err := params.Parse(spec.GetPayload()); err != nil {
			return fmt.Errorf("failed to parse DeleteSnapshot parameters: %w", err)
		}
		return f.executor.ExecuteDeleteSnapshot(ctx, &params)
		
	case DeleteOpaqueKey:
		var params DeleteOpaqueKeyParameters
		if err := params.Parse(spec.GetPayload()); err != nil {
			return fmt.Errorf("failed to parse DeleteOpaqueKey parameters: %w", err)
		}
		return f.executor.ExecuteDeleteOpaqueKey(ctx, &params)
		
	default:
		return fmt.Errorf("unknown handler %s", spec.GetType())
	}
}
